- [[Daily Log]]
	- 目标：
		- ((679c4414-1537-4bf9-a3cf-aa54f7fc2189))
		- ((679c4422-8c38-4f60-8083-f495fcfee934))
	- log：
		- 14:20-15:40 并发的八股
		- 15:40-16:47 睡觉
		- 16:50-17:40 并发的八股
		- 17:40-19:50 吃晚餐
		- 19:50-21:13 八股+面经
- DONE  并发的八股
  project:: [[Java并发]]
  collapsed:: true
	- 进程的五种状态与JVM线程的六种状态及切换命令
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.36
	  card-next-schedule:: 2025-02-06T23:22:34.723Z
	  card-last-reviewed:: 2025-02-02T23:22:34.723Z
	  card-last-score:: 3
	  id:: 6821b299-4a30-401f-8d5d-f5b75b8ca33f
	- 线程与线程组的关系，以及JVM与操作系统的线程优先级的关系
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:21:16.192Z
	  card-last-reviewed:: 2025-02-02T23:21:16.192Z
	  card-last-score:: 5
	  id:: 6821b299-51c5-4de8-8c44-3944cca9f03c
	- 进程存在哪些安全性问题
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:25:19.312Z
	  card-last-reviewed:: 2025-02-02T23:25:19.312Z
	  card-last-score:: 5
	  id:: 6821b299-9742-4bca-97f0-767ead7acdf1
	- 什么是happen-before 规则，这个规则要怎么遵循，有什么用
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.36
	  card-next-schedule:: 2025-02-06T23:20:49.416Z
	  card-last-reviewed:: 2025-02-02T23:20:49.416Z
	  card-last-score:: 3
	  id:: 6821b299-4902-494c-8611-e4e40c924f0f
	- 为什么volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性？JVM是怎么实现他的
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:17:51.801Z
	  card-last-reviewed:: 2025-02-02T23:17:51.801Z
	  card-last-score:: 5
	  id:: 6821b299-aecb-4cce-9808-6bef82876266
		- volatile是通过JVM调用CPU的指令来禁止指令重排序，通过写屏障volatile变量写入之前的所有变量，全部写入，再通过读屏障来保障接下来的读取指令都在写入发生之后。不能保证原子性的原因，是因为它只能保证单次写入和读取的原子性，无法保证组合指令的原子性。
			- 重入锁是指同一个线程可以多次获取同一把锁
	- synchronize 关键字属于什么锁，一般怎么用，可以锁些什么，能解决并发的哪些问题
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:16:08.172Z
	  card-last-reviewed:: 2025-02-02T23:16:08.172Z
	  card-last-score:: 5
	  id:: 6821b299-7be6-4a49-a8a8-cb054332e48b
		- 属于可重入锁，非公平锁，悲观锁，可以用来锁定对象和类，当用来锁定静态资源的时候，就是锁定能被因为静态资源就直接存储在内的静态方法池里面，而锁定一个代码快就是锁定的当前对象选的是this，也可以锁定指定的对象。
	- synchronize 的锁的四种状态及其转换条件
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:14:09.556Z
	  card-last-reviewed:: 2025-02-02T23:14:09.556Z
	  card-last-score:: 5
	  id:: 6821b299-5f85-4058-8399-bffac1538aaa
		- 锁在默认情况下是偏向锁，然后下一级是轻量锁在下一级是重量锁
			- 偏向锁就是记录了当前的线程ID，当同一个线程请求锁时，就不需再进行锁判断
			- 轻量级锁是多个线程竞争同一把锁时，竞争失败的线程会进入自旋状态。自旋成功的线程，它的下一次自旋次数会增加；自旋失败的线程，下一次自旋次数会减少。当自旋次数用尽之后，如果仍然未获得锁，那么就会升级成重量级锁。
			- 重量解锁则是互斥，所是利用操作系统的命令来达成的。
	- ReentrantLock 与 Synchronize 的区别
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:16:53.681Z
	  card-last-reviewed:: 2025-02-02T23:16:53.681Z
	  card-last-score:: 5
	  id:: 6821b299-3f10-4d59-98be-9d1d95c2d834
		- 都是重入锁，但是在R是基于AQS构造的，S是基于监视器，大并发下，R性能更好
		- R必须要手动释放，S可以自动释放
		- R是一个类，S是一个关键字
	- java的读写锁是什么，有什么特性
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:27:22.357Z
	  card-last-reviewed:: 2025-02-02T23:27:22.357Z
	  card-last-score:: 5
	  id:: 6821b299-16ef-4ab2-baf3-55115fe51f86
		- 读写锁分为读锁与写锁，先获取读锁再获取写锁，支持锁降级，不支持锁升级
		- 读写锁同时是可重入锁，且可以自己选择是否公平竞争
	- Java中锁的种类可以从哪些纬度区分
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:26:40.056Z
	  card-last-reviewed:: 2025-02-02T23:26:40.056Z
	  card-last-score:: 5
	  id:: 6821b299-aaaa-4965-b166-c716c142e6f3
		- 读写锁-独享锁
		  logseq.order-list-type:: number
		- 可重入锁-不可重入锁
		  logseq.order-list-type:: number
		- 自旋锁-适应性自旋锁
		  logseq.order-list-type:: number
		- 公平锁-非公平锁
		  logseq.order-list-type:: number
		- 乐观锁-悲观锁
		  logseq.order-list-type:: number
		- logseq.order-list-type:: number
	-
	-
- DONE  **百度二面**
  project:: [[八股]]
  :LOGBOOK:
  CLOCK: [2025-02-02 Sun 21:00:29]--[2025-02-02 Sun 21:13:15] =>  00:12:46
  :END:
	- ((679b3f85-faf6-491d-8fa8-7177a2f3fcf1))
		- JMM一套运行在家吧，虚拟机上的规范,他规定了所有的共享量都要放在主内存中，也就是运行内存区的圆空间中，然后每一个县城都有自己的工作空间，而工作空间中有公共变量的复制，每一个线程只能操纵工作空间中的变量的副本,县城之间的数据交换要通过主内存来进行JIM的规范保证了多线程环境下的一致性等问题
	- **JVM为什么要把堆和栈区分出来呢*#JVM
	  card-last-score:: 5
	  card-repeats:: 1
	  card-next-schedule:: 2025-02-06T23:35:17.411Z
	  card-last-interval:: 4
	  card-ease-factor:: 2.6
	  card-last-reviewed:: 2025-02-02T23:35:17.411Z
	  id:: 6821b299-a2eb-440d-8e5f-427298be8683
-
	-