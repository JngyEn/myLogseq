- DONE  简历业务方案
  project:: [[榴莲王]]
	- ### 下订单的并发问题
		- 并发问题的本质是共享资源的争夺与一致性问题，业务中则是对数据库中数据的读取和修改
		- #### 常见解决方案
			- 多线程角度：
			  logseq.order-list-type:: number
				- 分布式锁
				  logseq.order-list-type:: number
					- redis/redisson
					  logseq.order-list-type:: number
						- 根据用户ID和活动ID锁，锁的粒度小，不影响其他用户下单
						  logseq.order-list-type:: number
						- 锁住之后根据流水表等查询：
						  logseq.order-list-type:: number
							- 是否执行过该命令，可以实现幂等
							  logseq.order-list-type:: number
							- 订单状态，实现一人一单
							  logseq.order-list-type:: number
							- 扣减list，防止超卖
							  logseq.order-list-type:: number
				- 代码锁
				  logseq.order-list-type:: number
					- 集群部署时，代码锁无法控制全部实例
					  logseq.order-list-type:: number
			- 插入数据角度：
			  logseq.order-list-type:: number
				- 乐观锁
				  logseq.order-list-type:: number
				- 悲观锁
				  logseq.order-list-type:: number
					- 通过事务和 for update来保证修改操作的原子性和可见性
					  logseq.order-list-type:: number
		- 选用：
			- 分布式锁
	- ### 幂等问题
		- 幂等发生在短时间内多次执行相同请求，如果未做防幂等处理，那么并发下这些请求的判断全部相同。进而发生诸如重复下单的错误
		- #### 常见解决方案
			- 前端向后端请求并携带唯一操作的token，服务器存储并校验这些标识，防止做重复请求，并用数据库唯一约束兜底
			  logseq.order-list-type:: number
			- 请求携带UUID，通过缓存并检查UUID来防止网络重试导致的幂等问题
			  logseq.order-list-type:: number
			- 用分布式锁锁住请求，然后判断此操作是否进行过
			  logseq.order-list-type:: number
			- 定期扫描log表来对账，补偿重复操作
			  logseq.order-list-type:: number
		- 选用：
			- 分布式锁+定期对账
	- ### 防止超卖
		- 由于并发查询，多个线程得到了“库存充足”这个信息并进行库存扣件操作，导致超卖。
		- #### 常见解决方案
			- 并发角度：采用防止并发的手段来防止库存这个共享变量的并发读写问题
			  logseq.order-list-type:: number
			- 变量角度：
			  logseq.order-list-type:: number
				- 数据库原子操作来保证扣件操作的原子性
				  logseq.order-list-type:: number
					- 压力来到数据库
					  logseq.order-list-type:: number
				- 利用redis的单线程操作特性进行库存预扣件，防止超卖
				  logseq.order-list-type:: number
		- 选用：
			- Redis的list
				- 已经使用redis了
	- ### 一人一单
		- 指的是在用户未付款前，不得再创建新订单。本质是要查询付款状态
		- #### 常见解决方案
			- 使用带TTL的分布式锁，付款后解锁
			  logseq.order-list-type:: number
			- 对状态和用户id建立唯一索引
			  logseq.order-list-type:: number