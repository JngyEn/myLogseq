- [[Daily Log]]
	- 目标：
		- ((679b4892-00a6-44ad-a75c-c2930d58349d))
		- ((679b48ac-4496-40d2-b1cd-71bab4c9d8f0))
		- ((679b48b0-e5d6-4fe8-9b4b-a45bad621c8c))
		- 并发的八股
		- DONE 根对象有哪些
		- 一个面经
		- DONE 看机票，追踪价格变化，定住宿
		-
	- log：
		- 11:50-12:10 复习昨天的单词
- DONE  JVM 垃圾收集器和引用等剩余知识
  project:: [[JVM]]
  :LOGBOOK:
  CLOCK: [2025-02-01 Sat 17:16:38]--[2025-02-01 Sat 17:16:39] =>  00:00:01
  :END:
	- ((679b4440-8e7b-43af-a738-fecf7547b5dd))#card
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:34:32.973Z
	  card-last-reviewed:: 2025-02-02T23:34:32.973Z
	  card-last-score:: 5
	  id:: 6821b299-0062-4e2a-a226-d346f4c2911f
		- 三色分析法把对象按照不同的状态分为了三种颜色，黑色为所有的引用对象都被扫描过的对象，灰色为被扫描过的对象，但是他的引用对象还没有被完全扫描，白色为也没有被扫描过的对象。
		- 三色分析法，有三个阶段，第一阶段会标记所有的根对象，并且扫描这些跟对象的所有直接应用对象。第二阶段会从第一阶段产生的灰色对象开始遍历整个对象图。第三阶段会遍历第二阶段之后剩下的灰色对象开始继续按照规则标记。最后第三阶段结束之后清理掉白色对象。
			- 三色分析法相比较于可达性分析，最大的优势就是节省的STW的时间，因为只有第一阶段和第三阶段需要STW，第二阶段是与线程同步进行的。
			- 在并发标记阶段，会使用写屏障来记录对象引用的修改
		- 三色标记法有可能出现漏标或者是错标的问题。
			- 漏标问题不是很严重，因为在下一次GC中会得到修正
			- 错标问题则必须得到解决，发生错标要满足两个条件，一个是黑色对象引用了一个白色对象，第二个条件是其他的灰色对象都没有对这个白色对象的引用。
				- CMS通过增量更新的方式来破坏第一个条件，它会记录黑色对象的新应用，并且在重新标记阶段对这些对象进行扫描
				- G1通过原始快照的方式来破坏第二个条件，他会记录灰色对象的取消引用，并在重新标记阶段将这些对象标灰，虽然会造成原本应该释放掉垃圾对象依旧存活，但是因为漏标并不是什么太大的问题，所以可以接受
	- 垃圾收集器 #card
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:08:14.834Z
	  card-last-reviewed:: 2025-02-02T23:08:14.834Z
	  card-last-score:: 5
	  id:: 6821b299-66f9-4dbd-a6a3-3f92b48af488
		- CMS：
			- 使用三色标记法寻找垃圾，标记清除法清理垃圾
			- 在JDK9时被G1取代
		- G1:
			- 至今的默认垃圾收集器
			- 将内存划分为大小相同的区块，然后只是在逻辑上区分老年代和新生代
			- 通过两个区块之间标记-复制来保障不会存在内存碎片
			- 可以并发处理、可以限制垃圾收集时间、可以动态调整区块大小
		- ZGC：
			- ZGC 从 JDK 11 开始作为实验性功能引入，并在 JDK 15 中正式成为生产可用的功能。它的目标是实现**亚毫秒级**的停顿时间（通常小于 10 毫秒），即使堆内存达到数 TB 级别。
			-
	- 什么是强、软、弱、虚引用#card
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:34:44.574Z
	  card-last-reviewed:: 2025-02-02T23:34:44.574Z
	  card-last-score:: 5
	  id:: 6821b299-dc53-444a-8424-78068d4939c6
		- 按照OOM与GC为分界线，分割他们的生命周期
			- 无论如何都不会被回收的是强引用，也是正常new出来的对象
			- 普通GC时不会清理，OOM时会被清理的是软引用，用softReference创建
			- 下一次GC就会清理掉的是弱引用，用SoftReference
			- 虚引用不影响寿命周期，也不会被回收，他用来跟踪对象状态