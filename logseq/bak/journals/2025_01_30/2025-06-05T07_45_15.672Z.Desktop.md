- 复工复产咯！
- [[Daily Log]]
	- 目标：
		- 上午：9-12 三小时
			- DONE 背单词 1h（55个单词）
			- 复习单词 （半h）
			- DONE GRE 语法填空 （一个半h）
			- DONE 整理GRE方法
			  :LOGBOOK:
			  CLOCK: [2025-01-30 Thu 18:49:08]--[2025-01-30 Thu 18:49:09] =>  00:00:01
			  CLOCK: [2025-01-30 Thu 18:49:10]--[2025-01-30 Thu 18:49:10] =>  00:00:00
			  :END:
			- DONE 问czy
		- 下午：2-5 三小时
			- DONE 整理八股文每天看多少个
			- DONE 看今天的八股文并做好记录和复习
			- DONE 看面经
			- DONE 整理申研时间
			  :LOGBOOK:
			  CLOCK: [2025-02-06 Thu 15:33:47]--[2025-02-07 Fri 10:20:44] =>  18:46:57
			  :END:
		- 晚上：7-11 四小时
			- DONE 整理每天算法看多少个
			- 今天的算法
			- DONE 改出第一版面试稿子（2h）
	- log：
		- 10:55-11:20 背30个单词
			- 总结：25分钟，只能背25个单词，平均一分钟一个
		- 11:25-11:50 背25个单词
			- 11:44 背了13个
			- 到11:55 又背了15个
			- 总结：差不多是一分钟一个左右波动
		- 11:55-12:06 把最后的背完
		- 12:10-13:00 午餐
		- 13:00-13:55 选课
		- 13:55-14:15 午觉
		- 14:15-14:45 发邮件选课
		- 14:45-15:00 整理八股
			- 总结：看看一个番茄钟能过多少个吧
		- 15:05-15:30 JVM测试
			- 总结：不是很好计算，问题有多有少，但是像jvm这种，一天应该够了，保证时长吧，每天4h
		- 15:30-14:07 JVM内存模型及其衍生问题
		- 14:07-14:30 JVM内存模型，方法区和堆和栈的关系等
		- 14:30-17:45 JVM
		- 18:07-18:38 面经
- ---
- 整理一下前路，申研、考公、外企、国企、银行、私企 #前路
	- 时间、要求（资质）、待遇、可移动性
- DONE 清理液能上飞机吗？
-
- DONE JVM内存模型和其他相关知识  
  card-last-score:: nil
  card-repeats:: 0
  card-next-schedule:: nil
  card-last-interval:: -1
  card-ease-factor:: 2.5
  card-last-reviewed:: nil
  project:: [[JVM]]
  collapsed:: true
	- **Java是如何实现的平台无关**
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.36
	  card-next-schedule:: 2025-02-03T07:03:02.393Z
	  card-last-reviewed:: 2025-01-30T07:03:02.393Z
	  card-last-score:: 3
	  id:: 6821b299-cbbd-4943-8e95-2443ef890859
		- 通过编译器将代码编译成字节码，在通过不同平台的JVM将它字节码转译成对应平台上的机器码
	- **Java是编译型还是解释型?**
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:25:45.029Z
	  card-last-reviewed:: 2025-02-02T23:25:45.029Z
	  card-last-score:: 5
	  id:: 6821b299-b943-4397-b3bb-1a977e9c3418
		- 编译的意思是将你的高级源代码直接变成0101的机器码，CPU运行的话，它相当于每次编译出来的代码只能在对应的平台上运行。然后解释型的意思是我有一个解释器，然后可以将你的高级语言通过不同平台上的解释器直接解释成对应的可供这个平台执行的机器码。Java的过程是先用编译器，然后将Java代码编译成字节码，然后再通过JVM来执行字节码，将字节码变为对应的机器码。在这个过程中还引入了JIT技术，可以对热点的代码进行探测，探测到热点代码之后，热点代码会被直接编译成机器码，这样的话可以提升它的效率。探测的方式有很多种，HotSpot采用的是对方法块和循环块进行计数，高于某个阈值之后就判定它为热点代码。但是这样也可以带来些问题，就是你的JVM需要你的项目运行一段时间之后才可以达到一个比较好的效率。
	- Java类加载的过程
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:31:53.336Z
	  card-last-reviewed:: 2025-02-02T23:31:53.336Z
	  card-last-score:: 5
	  id:: 6821b299-2fc3-46f5-9dfc-e25e61aad252
		- 载入
		  logseq.order-list-type:: number
			- 先是从字节码中将内的基本信息加载到JVM内存的方法区中
			  logseq.order-list-type:: number
		- 验证
		  logseq.order-list-type:: number
			- 通过编译的一系列规则来检验输入的这一串二进制字节码是否符合限制
			  logseq.order-list-type:: number
		- 准备
		  logseq.order-list-type:: number
			- 为静态变量和常量在方法区中分配内存，static先赋值为默认值，而常量直接赋值
			  logseq.order-list-type:: number
		- 解析
		  logseq.order-list-type:: number
			- 将运行时常量池中的符号引用转化为具体的方法区中的内存地址的直接引用
			  logseq.order-list-type:: number
		- 初始化
		  logseq.order-list-type:: number
			- 为static赋值，在创建新实例、使用类的static资源时触发
			  logseq.order-list-type:: number
				- 变量存储在方法区中，对应的值`1`是字面量，存储在运行时常量池中。在初始化阶段，JVM会将运行时常量池中的`1`赋值给方法区中的`A`。字面量是只读的，不会被修改初次初始化之后，后续每次更改static的值，是直接修改方法区中`A`的值，而不会涉及运行时常量池。
				  logseq.order-list-type:: number
			- 假如是创建新实例，那么在初始化之后，jvm就会根据对象大小在堆中分配内存
			  logseq.order-list-type:: number
				- 然后再进行类初始化，调用构造函数等（与类加载过程中的初始化不同）
				  logseq.order-list-type:: number
	- **什么是双亲委派？如何破坏？**
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:35:25.737Z
	  card-last-reviewed:: 2025-02-02T23:35:25.737Z
	  card-last-score:: 5
	  id:: 6821b299-6fd2-4e61-b90d-160c2138ec1d
		- 双亲委派模型指的就是当一个类被某一个类加载器的去加载的时候，他会先使他的父加载器去尝试的，不行的话再由子加载器进行
	- 什么是栈帧，作用是什么，组成是什么，与栈的关系是什么，与线程的关系是什么
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:36:17.925Z
	  card-last-reviewed:: 2025-02-02T23:36:17.925Z
	  card-last-score:: 5
	  id:: 6821b299-3c32-4836-bc36-f1c08054fbaa
		- 栈帧的组成部分有操作数栈、局部变量表、动态链接、返回地址、指向方法区中的本方法的引用
		- 每个方法被调用时都会创建一个新的栈帧，返回地址为方法返回之后应该继续执行的位置
		- 线程包括程序计数器，本地方法栈、虚拟机栈
			- 虚拟机栈有一个个栈帧组成
			- 程序计数器指向正在执行的字节码指令的地址
	- JVM运行时内存区与JMM的关系是什么
	  id:: 679b3f85-faf6-491d-8fa8-7177a2f3fcf1
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:34:48.474Z
	  card-last-reviewed:: 2025-02-02T23:34:48.474Z
	  card-last-score:: 5
		- 运行时内存区主要关注的是内存，在被使用的时候，它的组织方式是怎么样的，而JMM主要是用来主要是一个抽象概念，用来划分不同的线程与主内存之间的一个交互方式，定义的多线程的规则
	- 对象都是分配在栈上吗？
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:33:26.354Z
	  card-last-reviewed:: 2025-02-02T23:33:26.354Z
	  card-last-score:: 5
	  id:: 6821b299-88d0-44fb-9698-aff01678d440
		- 不是的，JVM会通过逃逸分析来判断一个对象的生命周期是否会超过使用这个对象的方法，如果不会超过这个方法，那么就会将对象直接分配到栈
	- 什么是运行时常量池和字符串常量池？
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:32:40.417Z
	  card-last-reviewed:: 2025-02-02T23:32:40.418Z
	  card-last-score:: 5
	  id:: 6821b299-7c56-4c84-8b7c-2783d9e3aeaf
		- 字符串常量池是为了节省空间而使用的一块分配在堆上内存区域，字符串会被放在其中，会预定一些常用的字符串放在其中，同时会将用户创建的新的字符串也放在其中。
		- 运行时常量池则是字节码中的常量池放到方法区中（元空间）
	- 如何判断垃圾
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:32:45.117Z
	  card-last-reviewed:: 2025-02-02T23:32:45.117Z
	  card-last-score:: 5
	  id:: 6821b299-a245-4586-83a2-1151adbe4385
		- 引用计数法
		  logseq.order-list-type:: number
			- 缺点：无法解决循环依赖的垃圾
			  logseq.order-list-type:: number
		- 可达性分析（主流）
		  logseq.order-list-type:: number
			- 缺点：stw时间长
			  logseq.order-list-type:: number
				- 改进方法
				  logseq.order-list-type:: number
					- DONE 三色分析法
					  logseq.order-list-type:: number
					  id:: 679b4440-8e7b-43af-a738-fecf7547b5dd
					  :LOGBOOK:
					  CLOCK: [2025-02-01 Sat 11:52:55]--[2025-02-01 Sat 11:52:56] =>  00:00:01
					  :END:
	- 垃圾收集算法有哪些
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:19:57.540Z
	  card-last-reviewed:: 2025-02-02T23:19:57.541Z
	  card-last-score:: 5
	  id:: 6821b299-c0cd-4ae3-b44c-b31b6771bd70
		- 复制算法
		  logseq.order-list-type:: number
		- 标记清除算法
		  logseq.order-list-type:: number
		- 标记整理算法
		  logseq.order-list-type:: number
		- 结合上面的：分代收集
		  logseq.order-list-type:: number
			- 新生代：复制
			  logseq.order-list-type:: number
				- eden + suvivor form/to
				  logseq.order-list-type:: number
				- minor GC处理
				  logseq.order-list-type:: number
					- eden区满了时触发
					  logseq.order-list-type:: number
				- 16次存活之后进入老年代
				  logseq.order-list-type:: number
			- 老年代：标记清除或者整理
			  logseq.order-list-type:: number
				- 满了触发STW，进行major GC
				  logseq.order-list-type:: number
					- 也有可能被手动触发、或者方法区满了触发
					  logseq.order-list-type:: number
					- 空间分配担保失败时
					  logseq.order-list-type:: number
				- 直接进入老年代：
				  logseq.order-list-type:: number
					- 大对象
					  logseq.order-list-type:: number
					- 在新生代中，体积大于suvivor的一半的对象
					  logseq.order-list-type:: number
	- DONE 如何判断一个对象真正死亡了
	  id:: 679b4892-00a6-44ad-a75c-c2930d58349d
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:35:30.782Z
	  card-last-reviewed:: 2025-02-02T23:35:30.783Z
	  card-last-score:: 5
	  :LOGBOOK:
	  CLOCK: [2025-02-01 Sat 17:13:28]--[2025-02-01 Sat 17:13:29] =>  00:00:01
	  :END:
	- DONE 有哪些引用
	  id:: 679b48ac-4496-40d2-b1cd-71bab4c9d8f0
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:33:01.727Z
	  card-last-reviewed:: 2025-02-02T23:33:01.727Z
	  card-last-score:: 5
	- DONE 有哪些垃圾收集器
	  id:: 679b48b0-e5d6-4fe8-9b4b-a45bad621c8c
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:32:09.255Z
	  card-last-reviewed:: 2025-02-02T23:32:09.256Z
	  card-last-score:: 5
	-
- ---
- DONE  电商运营平台
  project:: [[业务常见八股]]
  collapsed:: true
  :LOGBOOK:
  CLOCK: [2025-01-30 Thu 18:38:57]--[2025-01-30 Thu 18:38:59] =>  00:00:02
  :END:
	- INSERT INTO student (id, name, age) VALUES (4, 'Bob', 23) ON DUPLICATE KEY UPDATE name = 'Bob'的限制、影响和额外加锁#mysql
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:26:34.847Z
	  card-last-reviewed:: 2025-02-02T23:26:34.847Z
	  card-last-score:: 5
	  id:: 6821b299-89aa-48e4-95f2-569cd341b37b
		- 加临间锁（next-key lock）= 间隙锁 + 记录锁，锁的范围是当前记录 + 前一个记录的间隙
		- 要求插入数据包括唯一索引或者主键且不为空值
		- 会发生主键跳跃
	- 为什么bigdecimal可以避免精度损失？#Java基础
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:24:59.569Z
	  card-last-reviewed:: 2025-02-02T23:24:59.570Z
	  card-last-score:: 5
	  id:: 6821b299-2472-494e-a366-40cece2af6c8
		- 用BigInterger来记录数值，再用一个BigInterger来记录小数点位置
		- 使用equal方法时，涉及到标度问题可能比较出错，应该用CompareTo
	- 包装类型与基本类型的关系，什么时候会进行自动装拆箱
	  card-last-interval:: 4
	  card-repeats:: 1
	  card-ease-factor:: 2.6
	  card-next-schedule:: 2025-02-06T23:14:36.197Z
	  card-last-reviewed:: 2025-02-02T23:14:36.197Z
	  card-last-score:: 5
	  id:: 6821b299-6e0f-44c1-a6fc-0c8bda0ec5c6
		- 包装类型的默认值为null，不会产生歧义
		- 自动：
			- 使用集合类型时
			- 与基本类型运算时
			- 作为返回值或者参数时
			- 三目运算符
			- 包装类型的运算
- ---
-