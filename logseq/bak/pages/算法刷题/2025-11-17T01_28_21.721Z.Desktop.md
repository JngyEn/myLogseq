 # 8天高强度刷题计划

### Day 1: 数组专项突破 (共 14 题)

- **重点**: 掌握二分查找、双指针、滑动窗口、矩阵等数组核心技巧。
- **任务**:
- [x]  3. 无重复字符的最长子串
- [ ]  4. 寻找两个正序数组的中位数 - hard
- [x]  11. 盛最多水的容器
	- 双指针：
		- 取值范围：\[left,right)，所以 while (left < right)
		- 判断逻辑：
			- 取当前两个指针中 高度最低的来算面积 -》 更新最大面积
		- 移动逻辑：
			- 哪边高度低，则移动哪边
- [x]  33. 搜索旋转排序数组
	- 双指针，获取当前区间中间位置值 mid-》mid与left位置判断来确定mid所在是反转后的左区间还是右区间 -〉若为左区间，判断target与left和mid的关系，如果target在左区间中，那么right = left - 1；否则 left = mid + 1
- [x]  34. 在排序数组中查找元素的第一个和最后一个位置
	- 双指针法找左边界，结束条件为leftIndex >= rightIndex：当num[mid] >= target的时候，rightIndex = mid - 1, left = rightIndex + 1; -> 双指针找右边界，当num[mid] > target的时候，leftIndex = mid + 1, right = leftIndex - 1; 
	- ![[Pasted image 20251116234534.png]]
- [x]  48. 旋转图像
- [x]  75. 颜色分类
	- 双指针
		- 取值范围：[i, rihgt], i <= right
			- left ：0的右边界+1，i：1的右边界+1，right：2的左边界-1
		- 判断逻辑：
			- 当前值为 0 ：交换 left 和 i的值，并且 i++ left ++
			- 当前值为1 ： i ++
			- 当前值为2: 交换 right 和 i 的值，并且 right--
- [ ]  76. 最小覆盖子串 - hard
- [x]  238. 除自身以外数组的乘积
- [x]  240. 搜索二维矩阵 II
- [x]  283. 移动零
	- 双指针 -》初始化 slow = fast = 0-〉num[fast] != 0时，slow位置值 = fast位置值 -》否则fast ++，从而依次移动非0元素 -〉当fast  = 数组长 -》从slow开始遍历将剩余元素设置为0
- [x]  438. 找到字符串中所有字母异位词
- [x]  448. 找到所有数组中消失的数字
- [x]  581. 最短无序连续子数组

### Day 2: 链表专项 (共 10 题)

- **重点**: 攻克链表基础操作、双指针应用、合并、反转等核心问题。
- **任务**:
- [x]  2. 两数相加
	- vH: 需要vH来返回新链表的头节点
	- 具体操作：
		- 终止条件：两个链表都为null 且 curSum 也为0了
		- 每次操作：
			- 相加当前数位和curSum获得 curSum
			- 取 % 获得个位构建新节点，取 / 获得十位 作为 下一位累进值
- [x]  19. 删除链表的倒数第N个节点
	- vH:需要vH来返回头节点
	- 具体操作：
		- 快指针前移 n 个，用 fast == null 来指示 慢指针到达 目标节点的pre -> 替换目标节点
		- 快指针初始化为 head，倒数 n 个 就移动 n次
		- 慢指针初始化为 vH, 和到位后的快指针一起移动，快指针为null 时，slow.next = target
- [x]  21. 合并两个有序链表
	- vH：需要一个vH来指向合并后链表的头节点
	- 具体操作：当两条链表的cur都不为null时遍历
		- 合并链表的cur节点指向两个链表cur当前值中小的那个
		- 有一个链表到达null之后，把剩下的那个链表接到合并链表尾部
- [ ]  23. 合并K个排序链表 - hard
- [x]  141. 环形链表
	- 快慢指针能 == 就行
- [x]  142. 环形链表 II
	- 先快慢指针得到交汇点k -> 初始化双指针，left 从 0， right 从k, 同步移动，相同点为环的入口
- [x]  148. 排序链表
	- 归并排序
	- 找到中点，slow or slow.next为中点(快慢指针，fast or fast.next 为null 时结束， slow 初始化为head，fast初始化为head.next) -> slow.next 为右半边头节点 -> 断开前后两端连接 -> 获得归并后左边头节点 -》 huode
- [x]  160. 相交链表
	- vH：不需要vH,直接返回的相交节点
	- 获得两条链表总长度 -> 将长的链表和短链表的开始节点对齐 -> 开始同步移动判断是否相交
- [x]  206. 反转链表
	- vH：不需要vH，因为不会对头节点有添加或者删除的操作
	- 双指针：pre.next指针指向cur, cur，从头节点开始。
		- 保存 cur.next -> 对cur 进行反转，指向pre ->  pre 前移 指向cur ->cur 前移 指向 temp
- [x]  234. 回文链表
	- vH：不需要vH，但是需要一个temp来指向head，作为第二次遍历的头节点
	- 具体操作：
		- 第一次遍历，全部入栈 -> 第二次遍历，每个位置对比

### Day 3: 哈希表、栈与堆 (共 15 题)

- **重点**: N数之和、栈和堆的经典应用，如单调栈、优先队列等。
- **任务**:
- [x]  1. 两数之和
- [x]  15. 三数之和
	- 排序 -》选择固定位，从小到大-〉跳过相同项-〉双指针跳过相同项找 == target
- [x]  20. 有效的括号
- [ ]  32. 最长有效括号 - hard
- [x]  49. 字母异位词分组
- [ ]  84. 柱状图中最大的矩形 - hard
- [x]  128. 最长连续序列
	- 将数组内容全部加入set中-》遍历set，从set不包含 cur - 1时开始计数-〉当set包含cur+1，则长度+1-》不包含时比较本次结果与历史结果
- [x]  155. 最小栈
- [x]  169. 多数元素
	- 遍历每个元素->当count = 0时，将当前元素设置为result -》当cur = result时，count++，否则-- -〉最后result代表的就是多值
- [x]  215. 数组中的第K个最大元素
- [ ]  239. 滑动窗口最大值 - hard
- [ ]  253. 会议室 II - 充值题目
- [x]  347. 前 K 个高频元素
- [x]  560. 和为K的子数组
	- 用map存< 前缀和的值，前缀和出现的次数>-》遍历数组，每一位累加 preSum->判断当前 preSum - target 的值有没有在map中 -〉在，则count + 改前缀和出现的次数 ——》不管怎么样，都将 preSum的值作为前缀和添加到map中，若有则+1
		- preSum[j] - preSum[i] = target —》preSum[j] - k =  preSum[i], 存在则说明满足条件
- [x]  739. 每日温度

### Day 4: 二叉树专项 (共 15 题)

- **重点**: 掌握二叉树的各种遍历方式、属性计算、构造方法以及路径问题。
- **任务**:
- [x]  94. 二叉树的中序遍历
- [x]  98. 验证二叉搜索树
- [x]  101. 对称二叉树
- [x]  102. 二叉树的层序遍历
- [x]  104. 二叉树的最大深度
- [x]  105. 从前序与中序遍历序列构造二叉树
- [x]  114. 二叉树展开为链表
- [ ]  124. 二叉树中的最大路径和 - hard
- [x]  226. 翻转二叉树
- [x]  236. 二叉树的最近公共祖先
- [ ]  297. 二叉树的序列化与反序列化 - hard
- [x]  437. 路径总和 III 
- [x]  538. 把二叉搜索树转换为累加树
- [x]  543. 二叉树的直径
- [x]  617. 合并二叉树

### Day 5: 回溯算法专项 (共 7 题)
```
main(){
	前置处理
	backtracking
}

void backtracking(参数) {
    if (收集条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
第1步：明确「选择」和「约束」
第2步：确定「传递参数」
第3步：确定「终止条件」

- 前置处理：
- 收集条件：
- 存放结果：
- 处理节点：
- 递归：
```
- **重点**: 系统学习回溯三部曲，解决组合、子集、排列、棋盘等经典问题。
- **任务**:
- [x]  17. 电话号码的字母组合
- [x]  22. 括号生成
- [x]  39. 组合总和
	- 前置处理：先排序
	- 收集条件：
		- 1. 当前值 > 目标值 或者 当前 index == 末尾 -> 直接返回，不收集
		- 2. 当前值 == 目标值，收集 
	- 存放结果：
	- 处理节点： curSum 添加num[i]，record 添加 num[i]
	- 递归：因为可以无限选取，所以直接用当前index递归
- [x]  46. 全排列
- [x]  78. 子集
	- 收集条件：无 = 每次都收集
	- 存放结果：默认每次都添加当前record到result中
	- 处理节点：添加当前元素
	- 递归：当前元素+1
- [x]  79. 单词搜索
		- 前置处理：
		- 收集条件：
		- 存放结果：
		- 处理节点：
		- 递归：
- [ ]  301. 删除无效的括号 - hard

### Day 6: 贪心算法专项 (共 4 题)

```
第1步：明确问题的「局部最优」是什么
	每一步要做什么选择？
	这一步的最优策略是什么？
	关键：找到贪心的「贪」在哪里
第2步：推导「局部最优」能否导出「全局最优」
	局部最优的累积能否得到全局最优？
	能否用反证法证明？
	有没有反例？
第3步：确定贪心策略（排序/选择规则）
	需要排序吗？按什么规则排序？
	每次选择的标准是什么？
	什么时候停止？
第4步：实现贪心选择
	用什么数据结构辅助？
	遍历顺序是什么？
	边界条件如何处理？
第5步：举例验证
	用简单例子模拟贪心过程
	检验是否得到最优解
	考虑特殊情况

```

- **重点**: 理解贪心思想的本质，解决区间、跳跃等经典贪心问题。
- **任务**:
- [x]  55. 跳跃游戏
	- 「局部最优」是什么
		- 在每个位置 `i`，我们能跳的最远距离是 `i + nums[i]`
	- 推导全局最优
		- 局部：每步都更新最远距离 → 全局：最终最远距离涵盖终点
	- 确定贪心策略
		- 如果 `i > maxReach`，说明这个位置根本到不了，返回 `false`
- [x]  56. 合并区间
	- 先按首位大小排序 -》从头开始遍历，把当前内容与record中最大区间比较-〉如果最大区间[1]〈 当前区间[0]，那么当前区间直接加入record-〉否则把最大区间[1]设置为当前区间[1]。
- [x]  406. 根据身高重建队列
- [ ]  621. 任务调度器

### Day 7: 动态规划（一）：基础与序列问题 (共 17 题)

```
- 确定dp数组含义
	- dp i,j 代表 i行j列结尾的路径最小和 
- 确定递推公式
	- dp {i} {j} = min dp(i-1)(j),dp(i)(j-1)
- 如何初始化
	- 所以要出实话i = 0的行和 j = 0的列；
- 遍历顺序
	- 只能是上或者左，看依赖关系，从前往后计算
- 举例推导
```

- **重点**: 掌握DP五部曲，集中攻克基础DP、子序列/子串、打家劫舍、背包等问题。
- **任务**:
- [ ]  5. 最长回文子串
- [x]  53. 最大子数组和
	- 5步：
		- 确定dp数组含义
			- dp[i] 为以 i 结尾的最大子数组和
		- 确定递推公式
			- 要么是cur[i],要么是dp[i-1] + cur[i]
		- 如何初始化
			- dp[0] 最大子数组和为 num[0]
		- 遍历顺序
			- dp 依赖 dp[i-1]
		- 举例推导
- [x]  62. 不同路径
	- 5步：
		- 确定dp数组含义
			- dp i,j 代表 i行j列结尾的总可能到达路径数
		- 确定递推公式
			- dp {i} {j} =  dp(i-1)(j) + dp(i)(j-1)
		- 如何初始化
			- 所以要出i = 0的行和 j = 0的列，全部初始化为1，只有一条路径能到
		- 遍历顺序
			- 只能是上或者左，看依赖关系，从前往后计算
		- 举例推导
- [x]  64. 最小路径和
	- 5步：
		- 确定dp数组含义
			- dp i,j 代表 i行j列结尾的路径最小和 
		- 确定递推公式
			- dp {i} {j} = min dp(i-1)(j),dp(i)(j-1)
		- 如何初始化
			- 所以要出实话i = 0的行和 j = 0的列；
		- 遍历顺序
			- 只能是上或者左，看依赖关系，从前往后计算
		- 举例推导
- [ ]  70. 爬楼梯
- [ ]  96. 不同的二叉搜索树
- [ ]  139. 单词拆分
- [x]  152. 乘积最大子数组
	- 确定dp数组含义
		- max[i]：i 结尾的最大积
		- min[i]：i结尾最小积
	- 确定递推公式，主要是正负的处理
		- max[i] = Max(num[i], num[i]*max[i], num[i]*min[i] )
		- min[i] = Min(num[i], num[i]*max[i], num[i]*min[i] )
		- 全局最大为 max和min中最大的那个
	- 如何初始化
		- 依赖max和min[i]，初始化为num[i]
	- 遍历顺序
		- 从小到大遍历
	- 举例推导
- [ ]  198. 打家劫舍
- [ ]  221. 最大正方形
- [ ]  279. 完全平方数
- [ ]  300. 最长上升子序列
- [ ]  322. 零钱兑换
- [ ]  337. 打家劫舍 III
- [ ]  416. 分割等和子集
- [ ]  494. 目标和
- [ ]  647. 回文子串

### Day 8: 动态规划（二）、图论与综合难题 (共 18 题)

- **重点**: 攻克DP难题（股票、编辑距离等），并接触图论、位运算及综合性设计题。
- **任务**:
- [ ]  10. 正则表达式匹配
- [ ]  31. 下一个排列
- [ ]  42. 接雨水
- [ ]  72. 编辑距离
- [ ]  85. 最大矩形
- [x]  121. 买卖股票的最佳时机
	- 遍历：-》buy 为当前价格和过去价格中最小的买入价格 -〉result为当前价格-buy的价格与历史最高价的高者
- [ ]  136. 只出现一次的数字
- [ ]  146. LRU 缓存机制
- [ ]  200. 岛屿数量
- [ ]  207. 课程表
- [ ]  208. 实现 Trie (前缀树)
- [ ]  287. 寻找重复数
- [ ]  309. 最佳买卖股票时机含冷冻期
- [ ]  312. 戳气球
- [ ]  338. 比特位计数
- [ ]  394. 字符串解码
- [ ]  399. 除法求值
- [ ]  461. 汉明距离
